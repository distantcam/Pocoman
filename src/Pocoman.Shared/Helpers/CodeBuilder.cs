using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis.Text;

internal interface IPartialTypeModel
{
    string? Namespace { get; }
    IReadOnlyList<string> TypeDeclarations { get; }
}

internal class CodeBuilder
{
    private static readonly string _assemblyName;
    private static readonly string _version;
    private static readonly string? _packageProjectUrl;
    private static readonly string? _gitSha;

    static CodeBuilder()
    {
        var assembly = Assembly.GetAssembly(typeof(CodeBuilder));
        _assemblyName = assembly.GetCustomAttribute<AssemblyTitleAttribute>().Title;
        _version = assembly.GetCustomAttribute<AssemblyVersionAttribute>()?.Version ?? "0.0.0.0";
        var metadata = assembly.GetCustomAttributes<AssemblyMetadataAttribute>()?.ToDictionary(m => m.Key, m => m.Value);
        if (metadata != null)
        {
            metadata.TryGetValue("PackageProjectUrl", out _packageProjectUrl);
            metadata.TryGetValue("GitSha", out _gitSha);
        }
    }

    private readonly StringBuilder _stringBuilder = new();
    private int _indent = 0;

    public CodeBuilder AppendLine()
    {
        _stringBuilder.AppendLine();
        return this;
    }
    public CodeBuilder AppendLine(string line)
    {
        _stringBuilder.AppendLine(Indent + line);
        return this;
    }
    public CodeBuilder AppendLineNoIndent(string line)
    {
        _stringBuilder.AppendLine(line);
        return this;
    }

    public CodeBuilder IncreaseIndent() { _indent++; return this; }
    public CodeBuilder DecreaseIndent()
    {
        if (_indent > 0)
        {
            _indent--;
        }
        return this;
    }

    public CodeBuilder OpenBlock()
    {
        AppendLine("{");
        IncreaseIndent();
        return this;
    }
    public CodeBuilder CloseBlock(string end = "}")
    {
        DecreaseIndent();
        AppendLine(end);
        return this;
    }

    public char IndentChar { get; set; } = '\t';
    public string Indent => new string(IndentChar, _indent);

    public CodeBuilder AddCompilerGeneratedAttribute() => AppendLine("[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]");

    public CodeBuilder AddGeneratedCodeAttribute() => AppendLine($"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{_assemblyName}\", \"{_version}\")]");

    public CodeBuilder AppendHeader() =>
    AppendLine($"//------------------------------------------------------------------------------")
    .AppendLine($"// <auto-generated>")
    .AppendLine($"//     This code was generated by {_packageProjectUrl}")
    .AppendLine($"//     Version: {_version}")
    .AppendLine($"//     SHA: {_gitSha}")
    .AppendLine($"//")
    .AppendLine($"//     Changes to this file may cause incorrect behavior and will be lost if")
    .AppendLine($"//     the code is regenerated.")
    .AppendLine($"// </auto-generated>")
    .AppendLine($"//------------------------------------------------------------------------------");

    public IDisposable StartPartialType(IPartialTypeModel typeModel)
    {
        if (!string.IsNullOrEmpty(typeModel.Namespace))
        {
            AppendLine($"namespace {typeModel.Namespace}");
            OpenBlock();
        }

        for (var i = 0; i < typeModel.TypeDeclarations.Count; i++)
        {
            AppendLine(typeModel.TypeDeclarations[i]);
            OpenBlock();
        }

        return new CloseBlockDisposable(this, typeModel.TypeDeclarations.Count + (typeModel.Namespace != null ? 1 : 0), "}");
    }

    public IDisposable StartBlock(string? line = null, string end = "}")
    {
        if (!string.IsNullOrEmpty(line))
            AppendLine(line!);
        OpenBlock();
        return new CloseBlockDisposable(this, 1, end);
    }

    public static implicit operator SourceText(CodeBuilder codeBuilder)
        => SourceText.From(codeBuilder._stringBuilder.ToString(), Encoding.UTF8);

    private readonly struct CloseBlockDisposable : IDisposable
    {
        private readonly CodeBuilder _codeBuilder;
        private readonly int _count;
        private readonly string _end;
        public CloseBlockDisposable(CodeBuilder codeBuilder, int count, string end) { _codeBuilder = codeBuilder; _count = count; _end = end; }
        public void Dispose() { for (var i = 0; i < _count; i++) _codeBuilder.CloseBlock(_end); }
    }
}
